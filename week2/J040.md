
# JAVA에서의 Lambda & Stream

https://devocean.sk.com/blog/techBoardDetail.do?ID=166237&boardType=techBlog

---

## (1) 도입 배경

- 자바 8 이후로 다음과 같은 기술들이 도입되고 강화되었다.
    - 메서드의 1급 시민화
    - 스트림 API
    - 인터페이스의 디폴트 메서드
- 디폴트 메서드를 활용해 컬렉션을 강화하였고, 거대한 컬렉션을 분산 환경에서 다루기 위한 병렬화 기술이 강화되었다.
- 그리고 이러한 컬렉션을 좀 더 효율적으로 다루기 위하여 스트림이 강화되었다.
- 그리고 이러한 스트림을 편리하게 사용하기 위해 선언형-함수형 프로그래밍이 도입되었다.
- 그리고 이러한 선언형-함수형 프로그래밍을 잘 다루기 위해 람다가 도입되었다.
- 결국 컬렉션을 효율적으로, 그리고 편리하게 잘 다루기 위한 것이 최종 목표인 것이다.

## (2) 람다란?

### [1] 정의

- 람다식은 메서드를 하나의 식으로 표현한 것이다.
- 람다는 코드 블록을 의미한다.
    - 구조 :  `(매개변수_목록) -> { 로직 }`
    - 특징 : 메서드 이름이 없다, 반환 타입이 없다.
- 람다식을 적용하면 메서드의 이름과 반환값이 없어지며, 그래서 람다를 익명함수라고 부르기도 한다.

### [2] 람다로 바꾸는 예시들

- example 1
    
    ```java
    void foo() {
        System.out.println("lambdadi lambdadi lambdadida");
    }
    
    () -> {
        System.out.println("lambdadi lambdadi lambdadida");
    };
    
    // 로직이 한 줄일 경우 중괄호까지 없앨 수 있음.
    () -> System.out.println("lambdadi lambdadi lambdadida");
    ```
    
- example 2
    
    ```java
    // example 2
    int max(int a, int b) {
      return a > b ? a : b;
    }
    
    (int a, int b) -> {
      return a > b ? a : b;
    }
    
    // 중괄호를 없애고, return과 맨 뒤의 세미콜론(;)까지 생략한 예시.
    (int a, int b) ->  a > b ? a: b
    
    // 매개변수 타입 추론이 가능하다면 매개변수 타입 생략까지도 가능하다.
    // 특수한 경우가 아니라면 람다의 모든 매개변수 타입은 생략하는 것이 좋다.
    (a, b) ->  a > b ? a: n
    ```
    
- example 3
    
    ```java
    // example 3
    // 매개변수가 하나인 경우
    
    (a) -> a * a
    
    a -> a * a
    ```
    
- 람다로 Enum 리팩토링하기
    
    ![img.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/a4aabbcc-5e84-46ac-8621-d050a2b903d7/1d842fbe-91e3-40f9-814a-b4d5ed58538e/img.png)
    
    ![img (1).png](https://prod-files-secure.s3.us-west-2.amazonaws.com/a4aabbcc-5e84-46ac-8621-d050a2b903d7/bd1a03fd-333d-47aa-8361-8d1cd4db29d6/img_(1).png)
    

### **[3] 함수형 인터페이스**

- 하나의 추상 메서드를 갖는 인터페이스를 함수형 인터페이스라고 한다. `@FunctionalInterface` 어노테이션을 사용하여 정의한다.
- 예시
    
    ```java
    @FunctionalInterface
    public interface MyFunctionalInterface {
        void execute();
    }
    ```
    
    ```java
    MyFunctionalInterface myFunc = () -> System.out.println("Lambda executed");
    myFunc.execute();
    ```
    
- Java는 다양한 함수형 인터페이스를 제공한다. 예를 들어, `Runnable`, `Supplier`, `Consumer`, `Function`, `Predicate`, `UnaryOperator` 등이 있으며, 이들은 각각의 용도에 맞게 Lambda를 사용할 수 있도록 도와준다.

### **[4] Stream**

- Stream은 연속된 데이터 항목들의 모임으로, 데이터 소스를 변경하지 않고 일회용으로 사용한다. Stream은 내부 반복을 통해 간결한 코드를 작성할 수 있다.
- 특징
    1. 데이터 소스를 변경하지 않는다.
    2. 일회용이다.
    3. 내부 반복 처리를 한다.
- 구성 요소
    - 중간 연산 : 반환값이 스트림인 연산으로, 여러 번 체이닝할 수 있다.
        - 예 : `filter`, `map`, `sorted`
    - 최종 연산 : 반환값이 스트림이 아닌 연산으로, 스트림을 소모한다.
        - 예: `forEach`, `collect`

### [5] Stream 최적화 전략

- Stream은 성능 최적화를 위해 지연 연산, 루프 퓨전, 쇼트 서킷 등의 기법을 사용한다.
1. 지연 연산 (Lazy Evaluation) : 최종 연산이 수행되기 전까지 중간 연산이 실제로 수행되지 않는다.
2. 루프 퓨전 (Loop Fusion) : 여러 중간 연산을 하나의 루프로 합쳐 데이터 접근 횟수를 줄인다.
    - 예시
        - 실제로는 한 번의 루프로 처리된다.
        
        ```java
        Stream.of(1, 2, 3)
            .peek(System.out::println)
            .peek(System.out::println)
            .forEach(System.out::println);
        ```
        
3. 쇼트 서킷 (Short Circuit) : 조건에 따라 중간에 연산을 멈춘다.
    - 예시
        
        ```java
        Stream.of(1, 2, 3, 4, 5)
            .filter(x -> x > 2)
            .limit(2)
            .forEach(System.out::println);
        ```
        

### **[6] 병렬 스트림 (Parallel Stream)**

- 병렬 스트림은 멀티코어 프로세서를 활용해 데이터를 병렬로 처리한다. `parallel()` 메서드를 사용하여 쉽게 병렬화를 적용할 수 있다.
- 사용 방법
    
    ```java
    Stream.of(1, 2, 3, 4, 5)
        .parallel()
        .forEach(System.out::println);
    ```
    
- 주의사항 : 병렬 스트림은 모든 경우에 성능이 향상되는 것은 아니므로 신중하게 테스트하고 적용해야 한다.
    - 병렬화가 적합한 경우: 연산량이 많고, 나누기 쉬운 자료구조(ArrayList, 배열 등)를 사용할 때
    - 부적합한 경우: 무한 스트림, 중간 연산에 `limit`을 사용하는 경우 등

### **[7] Lambda와 Stream의 장점**

- Lambda와 Stream을 사용하면 코드의 가독성을 높이고, 효율적으로 데이터를 처리할 수 있다.
- 가독성
    - 선언형 프로그래밍을 통해 코드가 더 간결하고 직관적이다.
- 유연성
    - 다양한 데이터 처리 작업을 더 쉽게 수행할 수 있다.
- 성능
    - 병렬 처리를 통해 성능을 향상시킬 수 있다.
